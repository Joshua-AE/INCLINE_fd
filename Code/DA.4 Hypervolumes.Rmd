---
title: "DA.4 Hypervolumes"
author: "Joshua et al."
date: "2023-10-20"
output: html_document
---
# Packages
```{r echo = FALSE, print = FALSE, message = FALSE, warning = FALSE}
library("tidyverse")
library("BAT") # computes functional metrics based on Mammola and Cardoso (2020)
library("hypervolume") # computes hypervolumes based on XY
library("fastDummies") # create dummy columns for cetegorical traits
```

# Re-arranging data frame
```{r}
raw_traits <- readr::read_tsv("../Input data/PFTC6_Incline_clean_leaf_traits_2022.txt", guess_max = Inf)
traits <- select(raw_traits, c(ID, siteID, blockID, warming, species, trait, value)) %>% na.omit() %>%
  filter(trait %in% c("ldmc", "leaf_area_cm2", "leaf_thickness_mm", "plant_height_cm", "sla_cm2_g"))# one sample removed: DLL3549

# all rows in the comm matrix have to sum to 1. rownames = sampling units, colnames = species
# traits in the traits table should be scaled, centered and not highly correlated. rownames = species, colnames = traits.
# colnames in comm and rownames in trait have to match!
```

# Hypervolume of all species in the control plots [mean values]
```{r, print = FALSE}
# This step calculates the mean value for each species, trait and treatment. It also removes 10 species that only occur in C or W.
trait_i <- traits %>% group_by(warming, species, trait) %>% summarise(mean_value = mean(value, na.rm = TRUE)) %>%
          pivot_wider(names_from = trait, values_from = mean_value)
trait_i <- trait_i %>%  ungroup() %>% left_join(as.data.frame(table(trait_i$species)), by = c("species" = "Var1")) %>% filter(Freq == 2)
trait_C <- trait_i %>% filter(warming == "C") %>% select(-c(warming, Freq)) %>% column_to_rownames(var = "species")
trait_W <- trait_i %>% filter(warming == "W") %>% select(-c(warming, Freq)) %>% column_to_rownames(var = "species")
trait_CW <- traits %>% group_by(species, trait) %>% summarise(mean_value = mean(value, na.rm = TRUE)) %>%
          pivot_wider(names_from = trait, values_from = mean_value)
trait_CW <- trait_CW %>% filter(species %in% row.names(trait_C)) %>% column_to_rownames(var = "species")

#This step creates the community matrix based on the trait tables. It does not matter for functional richness (Fric) computation if each species has abundance of 1 or 1/35 or 1/38 etc.
comm <- trait_C %>% mutate(all_sites = 1) %>% select(c(all_sites)) %>% t()

# The for() loop calculates Fric for each treatment group (control, OTC, both) 100 times
out <- list()
for(i in 1:100) {
  set.seed(0+i)
  print(i)
  hp <- kernel.build(comm = comm, trait = scale(trait_CW), distance = "euclidean", method.hv = "gaussian",
                             abund = FALSE, weight = NULL, axes = 0, convert = 0)
  out[[i]]  <- kernel.alpha(hp)
}

# The hypervolumes can be constructed with the given data or data can be transformed using PCoA after traits are dummyfied (if needed) and standardized (always). Beware that if transformations are required, all communities to be compared should be built simultaneously to guarantee comparability. In such case, one might want to first run hyper.build and use the resulting data in different runs of kernel.build. See function hyper.build for more details.

fric_CW <- as.data.frame(out)
colnames(fric_CW) <- c(1:100)
fric_CW <- fric_CW %>% t() %>% as.data.frame() %>% rename(fric_CW = Richness)

fric_all <- cbind(fric_C, fric_CW, fric_W)
fric_all <- pivot_longer(fric_all, cols = 1:3, names_to = "warming", values_to = "fric")

distr <- ggplot(fric_all, aes(x = fric, color = warming)) + 
  geom_density(data = subset(fric_all, warming == 'fric_C'),fill = "red", alpha = 0.2) +
  geom_density(data = subset(fric_all, warming == 'fric_W'),fill = "blue", alpha = 0.2) +
  geom_density(data = subset(fric_all, warming == 'fric_CW'),fill = "green", alpha = 0.2) +
  theme_classic() + scale_colour_manual(name  = "", breaks=c("fric_C", "fric_W", "fric_CW"), labels = c("C", "OTC", "Both"), values=c("red", "blue", "green")) +
  guides(color = guide_legend(override.aes = list(fill = c("red", "blue", "green")))) + theme(legend.position = c(0.9, 0.9))
# print 400 x 300
```

# site-specific hypervolumes
```{r, print = FALSE}
trait_all <- traits %>% group_by(siteID, warming, species, trait) %>% summarise(mean_value = mean(value, na.rm = TRUE)) %>%
             pivot_wider(names_from = trait, values_from = mean_value)
trait_all <- trait_all %>% mutate(uniqueID = paste(siteID, species, sep = " "))
trait_all <- trait_all %>% left_join(as.data.frame(table(trait_all$uniqueID)), by = c("uniqueID" = "Var1")) %>% filter(Freq == 2)
trait_all <- trait_all %>% group_by(siteID, warming) %>% mutate(LDMC = scale(ldmc), SLA = scale(sla_cm2_g),
             LA = scale(leaf_area_cm2), LTH = scale(leaf_thickness_mm), HEIGHT = scale(plant_height_cm))
trait_all <- trait_all %>% ungroup() %>% mutate(speciesID = paste(species, substr(siteID, 1,3), warming, sep = "_")) 

comm_all <- trait_all %>% mutate(site_CW = paste(substr(siteID, 1,3), warming)) %>% select(c(site_CW, speciesID)) %>% dummy_cols(select_columns = "site_CW", remove_selected_columns = T) %>% column_to_rownames(var = "speciesID") %>% t()
rownames(comm_all) <- c("Gud C", "Gud W", "Skj C", "Skj W", "Ulv C", "Ulv W")

trait_all <- trait_all %>% select(c(LDMC, SLA, LA, LTH, HEIGHT, speciesID)) %>% column_to_rownames(var = "speciesID")
trait_all[,1:5] <- unlist(trait_all[,1:5])

out <- list()
for(i in 1:10) {
  set.seed(0+i)
  print(i)
  hp <- kernel.build(comm = comm_all, trait = trait_all, distance = "euclidean", method.hv = "gaussian",
                             abund = FALSE, weight = NULL, axes = 0, convert = 0)
  out[[i]]  <- kernel.alpha(hp)
}

fric_sites <- as.data.frame(out)
colnames(fric_sites) <- c(1:10)
fric_sites <- fric_sites %>% t() %>% as.data.frame()

distr_sites <- ggplot(fric_all, aes(x = fric, color = warming)) + 
  geom_density(data = subset(fric_all, warming == 'fric_ulv'),fill = "red", alpha = 0.2) +
  geom_density(data = subset(fric_all, warming == 'fric_C_ulv'),fill = "blue", alpha = 0.2) +
  theme_classic() + scale_colour_manual(name  = "", breaks=c("fric_ulv", "fric_C_ulv"), labels = c("OTC", "Control"), values=c("red", "blue")) +
  guides(color = guide_legend(override.aes = list(fill = c("red", "blue")))) + theme(legend.position = c(0.2, 0.9))

```

# Functional divergence
```{r, print = FALSE}
rownames(C_gud) <- paste("C", rownames(C_gud), sep = "_") # renaming species to indicate they are from control plots
gud_trait <- rbind(trait_gud, C_gud) # binding the different mean traits together
comm_C_gud[,1:22] <- 0
colnames(comm_C_gud) <- paste("C", colnames(comm_C_gud), sep = "_")
gud_comm <- cbind(comm_gud, comm_C_gud)
gud_comm <- rbind(gud_comm, c(rep(0, 22), rep(1, 22)))
rownames(gud_comm) <- c("OTC", "Control") # total Beta diversity between gud OTC and control is 0.238

out <- list()
for(i in 1:100) {
  set.seed(0+i)
  print(i)
hvlist = kernel.build(comm = gud_comm, trait = gud_trait, distance = "euclidean", method.hv = "gaussian",
                             abund = FALSE, weight = NULL, axes = 0, convert = 0)
beta <- kernel.beta(hvlist)
out[[i]] <- beta$Btotal[1]
}
beta_gud <- out %>% as.data.frame() %>% t() %>% as.data.frame()
sd(beta_skj$V1)
```



# Hypervolume of all samples in the control plots
```{r, print = FALSE}
# some species are over-represented
# how strongly are traits correlated? Do PCA if too correlated!
trait <- traits %>% filter(warming == "C") %>% select(c(ID, trait, value))
trait <- pivot_wider(trait, id_cols = ID, names_from = trait, values_from = value)
trait <- trait %>% column_to_rownames(var = "ID")  %>% na.omit() # 35 samples with incomplete trait data removed
trait[,1:5] <- scale(trait[,1:5], center = T, scale = T)

comm <- trait %>% mutate(all_sites = 1/688) %>% select(-c(ldmc, leaf_area_cm2, leaf_thickness_mm, plant_height_cm, sla_cm2_g)) %>% t()

# trait correlations
cor_matrix1 <- pairs.panels(trait[,1:5], smooth = TRUE, ellipse = FALSE, method = "spearman", hist.col = 5, stars = TRUE)
cor_matrix2 <- trait %>% cor(method = "spearman") %>% round(2) %>% abs() # same as pairs.panel
cor_matrix2[cor_matrix2 == 1] <- NA
#Spearman's ρ is 1 if correlation is monotonic and Pearson's r is 1 if correlation is monotonic and linear. If ρ > r,  correlation is monotonic but not linear.
test <- prcomp(trait, center = F, scale. = F)
summary(test)
set.seed(1)
hypervolume <- kernel.build(comm = comm, trait = trait, distance = "euclidean", method.hv = "gaussian",
                             abund = FALSE, weight = NULL, axes = 0, convert = 0)

fric <- kernel.alpha(hypervolume)
fric <- as.data.frame(fric)

```
